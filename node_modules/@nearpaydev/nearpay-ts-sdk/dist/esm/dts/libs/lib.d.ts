import { CONNECTION_STATE } from "./types";
import { NearpayConnector } from "./connectors/AbstractConnector";
import { ConnectionInfo, ConnectorInfo, NEARPAY_CONNECTOR } from "./connectors/types";
import { RemoteJobRequest } from "./payload/types";
import { ProfileType } from "./terminal/types";
/**
 * Nearpay object is the object used to create connectins, revice and send payments, etc
 * nearpay will have a connector object when its connected
 *
 * Nearpay also is an EventTarget that can listen to events like pay, connectivity change,
 * payment result, etc. These events are used to comunicate with the client app
 *
 * the way the client app will get access these events will be with a wrappers that wraps
 * an event listener, (see src/wrapper.tsx)
 */
export default abstract class Nearpay {
    /**
     * lib_provider will provide classes and utilities to Nearpay
     *
     * you can see description of it on the class comments
     */
    private lib_provider;
    private state;
    private is_paused;
    private is_busy;
    private recovaryMode;
    private tryingToConnect;
    private is_loggedin;
    constructor();
    /**
     * a short cut for using add event listener to the connectivity-change listener
     * to avoid the usage of event.details
     *
     * 9/4/2023
     * we started using (event-target-shim) so the implementation changes a bit, because new package
     * doesn't have custom events
     *
     * @param callback function that takes state and deal with it,
     * it should be provided from the client
     * @returns a function that removes the listener
     */
    addConnectivityListener(callback: (state: CONNECTION_STATE) => void): () => void;
    /**
     * handle pause and resume states from the pos device
     *
     * @param callback callback to run on pause or resume
     * @returns remover for listener
     */
    addPauseListener(callback: (is_pause: boolean) => void): () => void;
    /**
     * handle busy and confirm states from the pos device
     *
     * @param callback callback to run on confirm or busy
     * @returns remover for listener
     */
    addBusyListener(callback: (is_busy: boolean) => void): () => void;
    /**
     * add a reconnect listener to auto reconnect after disconnection
     * retruns a remover to remove the listener
     *
     * @param delay delay for reconnect
     * @returns a remover function
     */
    addAutoReconnect(delay?: number): () => void;
    getConenctor(): NearpayConnector | undefined;
    getConnectorType(): NEARPAY_CONNECTOR | undefined;
    getCurrentConnectionInfo(): ConnectionInfo | undefined;
    getAvaliableConnector(): Promise<ConnectorInfo[]>;
    private releaseConnector;
    /**
     * will return undefined when connection success, or else it will return a string
     * with the error message
     */
    connect(connectionInfo: ConnectionInfo): Promise<void>;
    /**
     * connect to the last user used
     *
     * @returns connection error
     */
    connectToLastUser(): Promise<void>;
    reconnect(profileId: string): Promise<void>;
    /**
     *  send data to pos, will send only if the connection is avalible and
     * the device is not in pause mode
     *
     * @param data data to send to pos
     * @returns promise of value or undefined
     */
    send(data: RemoteJobRequest<any>): Promise<any>;
    /**
     * mark the last message as rejected
     */
    cancelJob(reason?: string): void;
    isConnected(): boolean;
    isLogedIn(): boolean;
    getState(): CONNECTION_STATE;
    isPaused(): boolean;
    isBusy(): boolean;
    disconnectDevice(): void;
    /**
     * forget the current conncetion info
     *
     * @returns boolean of the forget
     */
    forgetDevice(): Promise<boolean | undefined>;
    getTerminal(): import("./terminal/terminal").Terminal;
    /**
     *
     * @returns indicates if there is a job not finished yet
     */
    hasPendingJob(): boolean;
    /**
     * will try to recover if the connetion disonnected
     *
     not finished yet
     */
    private recoveryAfterDisconnection;
    private getIdOrGenerate;
    /**
     * check if the profile id saved is valid or not
     * if valid then it can be used to connect
     * else it will ask for new uuid
     *
     * @param connectionInfo ip and port of connection
     * @returns boolean indicates the profile id is valid
     */
    private checkProfileIdIsValid;
    /**
     * request a connection uuid from the POS device
     * device could response with "busy" or "uuid:<uuid-to-use>"
     *
     * @param connectionInfo
     * @returns uuid or undefined
     */
    private requestConnectionUuid;
    /**
     * start new connection with the pos device
     * @param connectionInfo connection info
     * @param estableshedUuid profile uuid to use
     * @returns
     */
    private StartConnection;
    /**
     * we started using this new methods after we added the react native part to the project
     * since there is platform specific code that will apply only to certain platforms, like localStorage
     */
    getProfile(): Promise<ProfileType | undefined>;
    saveProfile(profile: ProfileType): Promise<void>;
    getLastConnection(): Promise<ConnectionInfo | undefined>;
    saveConnection(connection: ConnectionInfo): Promise<void>;
}
