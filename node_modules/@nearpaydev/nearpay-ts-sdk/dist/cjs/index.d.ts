import { EventTarget } from 'event-target-shim';

declare enum JOB_COMMAND {
    PURCHASE = "0",
    REFUND = "1",
    RECONCILE = "2",
    REVERSE = "3",
    GET_PENDING_TRANSACTIONS = "4",
    GET_REVERSIBLE_TRANSACTIONS = "5",
    GET_REFUNDABLE_TRANSACTIONS = "6",
    GET_TRANSACTION = "7",
    GET_ALL_RECONCILIATIONS = "8",
    GET_RECONCILIATION = "9",
    LOGOUT = "10"
}
declare enum JOB_COMMANDTYPE {
    CREATE = "0",
    CANCEL = "1",
    END = "2"
}

type LocalizationField = {
    arabic: string;
    english: string;
};
type LabelField<T> = {
    label: LocalizationField;
    value: T;
};
type NameField<T> = {
    name: LocalizationField;
    id: T;
};

type TransactionData = {
    receipts?: TransactionReceipt[];
    isNewTransaction?: boolean;
};
type TransactionReceipt = {
    receipt_id: string;
    merchant: Merchant;
    start_date: string;
    start_time: string;
    card_scheme_sponsor: string;
    tid: string;
    system_trace_audit_number: string;
    pos_software_version_number: string;
    retrieval_reference_number: string;
    card_scheme: NameField<string>;
    transaction_type: NameField<string>;
    pan: string;
    card_expiration: string;
    amount_authorized: LabelField<string>;
    amount_other: LabelField<string>;
    currency: LocalizationField;
    status_message: LocalizationField;
    is_approved: boolean;
    is_refunded: boolean;
    is_reversed: boolean;
    approval_code?: LabelField<string>;
    verification_method: LocalizationField;
    end_date: string;
    end_time: string;
    receipt_line_one: LocalizationField;
    receipt_line_two: LocalizationField;
    thanks_message: LocalizationField;
    save_receipt_message: LocalizationField;
    entry_mode: string;
    action_code: string;
    application_identifier: string;
    terminal_verification_result: string;
    transaction_state_information: string;
    cardholader_verfication_result: string;
    cryptogram_information_data: string;
    application_cryptogram: string;
    kernel_id: string;
    payment_account_reference?: string;
    pan_suffix?: string;
    created_at: string;
    updated_at: string;
    qr_code: string;
    transaction_uuid: string;
};
type Merchant = {
    id: string;
    name: LocalizationField;
    address: LocalizationField;
    category_code: string;
};
declare enum TransactionType {
    UNDEFINED = "-1",
    PURCHASE = "00",
    CASH = "01",
    CASH_DISBURSEMENT = "17",
    PURCHASE_WITH_CASHBACK = "09",
    REFUND = "20"
}
type TransactionBannerList = {
    total: number;
    transactionBanners: TransactionBanner[];
};
type TransactionBanner = {
    uuid: String;
    scheme: String;
    pan: String;
    amount_authorized: String;
    currency: LocalizationField;
    transaction_type: TransactionType;
    is_approved: Boolean;
    is_reversed: Boolean;
    start_date: String;
    start_time: String;
    customer_reference_number?: string;
};

type ReconciliationBannerList = {
    total: number;
    reconciliations: ReconciliationBanner[];
};
type ReconciliationBanner = {
    id: String;
    date: String;
    time: String;
    is_balanced: LabelField<Boolean>;
    total: String;
    currency: LocalizationField;
};
type ReconciliationReceipt = {
    id: string;
    date: string;
    time: string;
    is_balanced: LabelField<Boolean>;
    details: ReconciliationDetailsType;
    schemes: ReconciliationSchemesType[];
    currency: LocalizationField;
    qr_code: string;
    merchant: Merchant;
    tid: string;
    system_trace_audit_number: string;
    pos_software_version_number: string;
};
type ReconciliationDetailsType = {
    purchase: ReconciliationLabelField;
    refund: ReconciliationLabelField;
    purchase_reversal: ReconciliationLabelField;
    refund_reversal: ReconciliationLabelField;
    total: ReconciliationLabelField;
};
type ReconciliationSchemesType = {
    name: LabelField<string>;
    pos: ReconciliationSchemesDetailsType;
    host: ReconciliationSchemesDetailsType;
};
type ReconciliationSchemesDetailsType = {
    debit: ReconciliationLabelField;
    credit: ReconciliationLabelField;
    total: ReconciliationLabelField;
};
type ReconciliationLabelField = {
    label: LocalizationField;
    total: String;
    count: number;
};

type PayloadMetaDataType = {
    platform: string;
    device_id: string;
    device_user: string;
    os_version: string;
    sdk_version: string;
    payment_plugin_version: string;
};
type RemoteJobRequest<PayloadType> = {
    jobId: string;
    messageId: string;
    command: JOB_COMMAND;
    commandType: JOB_COMMANDTYPE;
    metaData: PayloadMetaDataType;
    payload: PayloadType;
};
type RemoteJobResponse<PayloadType> = {
    jobId: string;
    messageId: string;
    command: JOB_COMMAND;
    commandType: JOB_COMMANDTYPE;
    metaData: PayloadMetaDataType;
    payload: PayloadType;
};
type RemotePurchaseResponse = RemoteJobResponse<{
    message: string | null;
    status: PURCHASE_STATUS;
    transactionReceipts: TransactionReceipt[] | null;
}>;
type RemoteRefundResponse = RemoteJobResponse<{
    message: string | null;
    status: REFUND_STATUS;
    transactionReceipts: TransactionReceipt[] | null;
}>;
type RemoteReversalResponse = RemoteJobResponse<{
    message: string | null;
    status: REVERSAL_STATUS;
    transactionReceipts: TransactionReceipt[] | null;
}>;
type RemoteReconciliationResponse = RemoteJobResponse<{
    message: string | null;
    status: RECONCILIATION_STATUS;
    reconcileReceipt: ReconciliationReceipt | null;
}>;
declare enum COMMAND_WORD {
    Busy = "busy",
    Paused = "Paused",
    Paused_Mode = "PausedAlready",
    Resume = "Resume",
    Confirmed = "confirmed",
    Unauthorized = "unauthorized"
}
declare enum PURCHASE_STATUS {
    APPROVED = 1,
    DECLINED = 2,
    REJECTED = 3,
    AUTHENTICATION_FAILED = 4,
    INVALID_DEVICE_STATUS = 5,
    GENERAL_FAILURE = 6
}
declare enum REFUND_STATUS {
    APPROVED = 1,
    DECLINED = 2,
    REJECTED = 3,
    AUTHENTICATION_FAILED = 4,
    INVALID_DEVICE_STATUS = 5,
    GENERAL_FAILURE = 6
}
declare enum REVERSAL_STATUS {
    FINISHED = 1,
    REJECTED = 2,
    AUTHENTICATION_FAILED = 3,
    INVALID_DEVICE_STATUS = 4,
    GENERAL_FAILURE = 5
}
declare enum RECONCILIATION_STATUS {
    BALANCED = 1,
    NOT_BALANCED = 2,
    REJECTED = 3,
    AUTHENTICATION_FAILED = 4,
    INVALID_DEVICE_STATUS = 5,
    GENERAL_FAILURE = 6
}
declare enum TRANSACTION_QUERY_STATUS {
    FINISHED = 1,
    AUTHENTICATION_FAILED = 3,
    INVALID_DEVICE_STATUS = 4,
    GENERAL_FAILURE = 5
}
declare enum TRANSACTIONS_QUERY_STATUS {
    FINISHED = 1,
    AUTHENTICATION_FAILED = 2,
    INVALID_DEVICE_STATUS = 3,
    GENERAL_FAILURE = 4
}
declare enum RECONCILIATIONS_QUERY_STATUS {
    FINISHED = 1,
    AUTHENTICATION_FAILED = 2,
    INVALID_DEVICE_STATUS = 3,
    GENERAL_FAILURE = 4
}
declare enum RECONCILIATION_QUERY_STATUS {
    BALANCED = 1,
    NOT_BALANCED = 2,
    REJECTED = 3,
    AUTHENTICATION_FAILED = 4,
    INVALID_DEVICE_STATUS = 5,
    GENERAL_FAILURE = 6
}

type ProfileType = {
    id: string;
};
type PurchaseOptions = {
    jobId?: string;
    messageId?: string;
    amount: number;
    reference_id?: string;
    enable_receipt_ui?: boolean;
    enable_reversal?: boolean;
    finish_timeout?: number;
    enable_ui_dismiss?: boolean;
};
type RefundOptions = {
    jobId?: string;
    messageId?: string;
    amount: number;
    original_transaction_uuid: string;
    enable_ui_dismiss?: boolean;
    reference_id?: string;
    enable_receipt_ui?: boolean;
    enable_reversal?: boolean;
    enable_editable_refund_amount_ui?: boolean;
    finish_timeout?: number;
};
type ReversalOptions = {
    jobId?: string;
    messageId?: string;
    original_transaction_uuid: string;
    enable_receipt_ui?: boolean;
    finish_timeout?: number;
};
type ReconcileOptions = {
    jobId?: string;
    messageId?: string;
    enable_receipt_ui?: boolean;
    finish_timeout?: number;
};

type SessionData = {
    id: string;
    status: string;
    type: string;
    client_id: string;
    amount: string;
    expired_at: string;
    reference_id?: string;
    created_at: string;
    updated_at: string;
    transaction?: SessionTransaction;
};
type SessionTransaction = {
    id?: string;
    uuid?: string;
    amount_authorized?: string;
    transaction_currency_code?: string;
    cardholder_verification_result?: string;
    lat?: string;
    lon?: string;
    transaction_type?: string;
    card_scheme_id?: string;
    system_trace_audit_number?: string;
    is_approved?: boolean;
    is_reversed?: boolean;
    is_reconcilied?: boolean;
    device_id?: string;
    user_id?: string;
    merchant_id?: string;
    customer_reference_number?: string;
    pos_confirmed?: boolean;
    created_at?: string;
    updated_at?: string;
    receipts: TransactionReceipt[];
    card_scheme: LocalizationField;
    type: LocalizationField;
    verification_method: LocalizationField;
};

declare enum CONNECTION_STATE {
    CONNECTED = "connected",
    CONNECTING = "connecting",
    DISCONNECTED = "disconnected",
    LOGGED_OUT = "logged_out"
}
type ConnectorDisconnectOptions = {
    force: boolean;
};

type SendMessageOptions = {
    timeout?: number;
};
/**
 * ConnectionManager is responsible for managing the messages sent by the sdk
 * ConnectionManager can accept the messages (mark them as recived) and
 * cancel messages (make htem rejected with  reason)
 *
 * all messages from the SDK should go throgh the ConnectionManager with the sendMessage function
 *
 * have access to the provider
 */
declare class ConnectionManager {
    private lib_provider;
    /**
     * saves the messages that are pending now
     * message should be cleared after recive or reject
     */
    private inbox;
    constructor(lib_provider: NearpayLibProvider);
    /**
     * register a message to the pos inbox
     * to be precise it doesnot send the message, it wraps the sending
     *
     * @param jobId jobId for message
     * @param sendFunction the function that is used to send
     * @param options options for the send
     * @returns the promise for response
     */
    sendJob(jobId: string, payload: RemoteJobRequest<any>, sendFunction: () => Promise<void> | void, { timeout }?: SendMessageOptions): Promise<any>;
    /**
     * handle the command recived, command can be found in COMMAND_WORD
     *
     * @param cmd command to handle
     */
    reviceCommand(cmd: COMMAND_WORD): Promise<void>;
    /**
     * mark a job as recived and resolve a value
     *
     * @param jobId of the recived message
     * @param data data to resolve
     */
    reciveJob(jobId: string, data: object): Promise<void>;
    /**
     * reject a message for reson
     *
     * @param jobId id for message to reject
     * @param reason reson for rejection
     */
    rejectJob(jobId: string, reason?: string): Promise<void>;
    /**
     * reject all messages
     * @param reason reson for rejection
     */
    rejectAllJobs(reason?: string): Promise<void>;
    /**
     * reject last message
     *
     * @param reason reson for rejection
     */
    rejectLastJob(reason?: string): Promise<void>;
    /**
     * @returns number of pending messages in the inbox
     */
    hasPendingJob(): boolean;
    private sendCancel;
}

declare const NearpayEvents: readonly ["connected", "disconnected", "state-connected", "state-connecting", "state-disconnected", "state-logged_out", "logout", "connectivity-change", "availablity-change", "pay", "payment-result", "setup", "send-message", "recive-message", "reject-message", "pause", "un-pause", "connection-busy", "connection-not-busy"];
declare type NearpayEvent = typeof NearpayEvents[number];

/**
 * will handle listening and emmeting events to Nearpay object
 *
 * have access to the provider
 */
declare class NearpayListener {
    private lib_provider;
    constructor(lib_provider: NearpayLibProvider);
    private event;
    addEventListener(type: NearpayEvent, callback: EventTarget.EventListener<any, any>, options?: EventTarget.AddOptions): () => void;
    removeEventListener(type: NearpayEvent, callback: EventTarget.EventListener<any, any>, options?: EventTarget.AddOptions): void;
    dispatchEvent(eventName: NearpayEvent): void;
    dispatchConnectivityChange(state: CONNECTION_STATE): void;
}

/**
 * NearpayLibProvider is used to provide classes internally to Nearpay object
 *
 * the provided object can also use any class provided from NearpayLibProvider
 *
 * NearpayLibProvider is meant to be internal use only, client cant use it
 *
 * the idea of the provider is that all classes will be added and accessed easily, also ot adds a level of abstraction
 * to the code, so the NearPay object will show only the required method
 *
 * for example, the provider will provide listener and connection manager to nearpay object, then
 * listener will have eccess to connection manager and nearpay, and connection manger will have the same case
 */
declare class NearpayLibProvider {
    constructor(nearpay: Nearpay);
    /**
     *  (2/1/2023)
     * terminal added to handle the transaction
     * it will be returned from the login function
     *
     * it should be updated every time the login function is called, to
     * keep the object consestent around the application
     */
    private terminal;
    private nearpay;
    private listener;
    private connector;
    private connection_manager;
    getTerminal(): Terminal;
    getNearpay(): Nearpay;
    getListener(): NearpayListener;
    getConnector(): NearpayConnector | undefined;
    getConnectionManager(): ConnectionManager;
    setConnector(connector: NearpayConnector | undefined): void;
}

declare class Terminal {
    private lib_provider;
    constructor(lib_provider: NearpayLibProvider);
    /**
     * updates the terminal and returns it self
     * @returns terminal it self
     */
    private update;
    /**
     * do a purchase transaction and return a transaction object
     * @param amount the purcahse amount
     * @param reference_id optional, customer referance id
     * @param enable_receipt_ui optional, enable ui receipt
     * @param enable_reversal optional, enable reversal of transaction
     * @param finish_timeout optional, timeout in seconds
     * @returns a purchase response
     */
    purchase({ jobId, messageId, amount, enable_ui_dismiss, reference_id, enable_receipt_ui, enable_reversal, finish_timeout, }: PurchaseOptions): Promise<RemotePurchaseResponse>;
    /**
     * do a refund reansaction and return a transaction object
     *
     * @param amount the refund amount
     * @param original_transaction_uuid the original transaction id of the refunded transaction
     * @param reference_id optional, customer referance id
     * @param enable_receipt_ui optional, enable ui receipt
     * @param enable_editable_refund_amount_ui optional, enable editing refund amount from ui
     * @param enable_reversal optional, enable reversal of transaction
     * @param finish_timeout optional, timeout in seconds
     * @returns a refund response
     */
    refund({ jobId, messageId, amount, original_transaction_uuid, enable_ui_dismiss, reference_id, enable_receipt_ui, enable_reversal, enable_editable_refund_amount_ui, finish_timeout, }: RefundOptions): Promise<RemoteRefundResponse>;
    /**
     * do a reversal reansaction and return a transaction object
     *
     * @param original_transaction_uuid the original transaction id of the refunded transaction
     * @param enable_receipt_ui optional, enable ui receipt
     * @param finish_timeout optional, timeout in seconds
     * @returns a reversal response
     */
    reversal({ jobId, messageId, original_transaction_uuid, enable_receipt_ui, finish_timeout, }: ReversalOptions): Promise<RemoteReversalResponse>;
    /**
     * do a reconcilation using ui
     *
     * @param enable_receipt_ui optional, enable ui receipt
     * @param finish_timeout optional, timeout in seconds
     * @returns a reconciliation response
     */
    reconcile({ jobId, messageId, enable_receipt_ui, finish_timeout, }: ReconcileOptions): Promise<RemoteReconciliationResponse>;
}

/**
 * Nearpay object is the object used to create connectins, revice and send payments, etc
 * nearpay will have a connector object when its connected
 *
 * Nearpay also is an EventTarget that can listen to events like pay, connectivity change,
 * payment result, etc. These events are used to comunicate with the client app
 *
 * the way the client app will get access these events will be with a wrappers that wraps
 * an event listener, (see src/wrapper.tsx)
 */
declare abstract class Nearpay {
    /**
     * lib_provider will provide classes and utilities to Nearpay
     *
     * you can see description of it on the class comments
     */
    private lib_provider;
    private state;
    private is_paused;
    private is_busy;
    private recovaryMode;
    private tryingToConnect;
    private is_loggedin;
    constructor();
    /**
     * a short cut for using add event listener to the connectivity-change listener
     * to avoid the usage of event.details
     *
     * 9/4/2023
     * we started using (event-target-shim) so the implementation changes a bit, because new package
     * doesn't have custom events
     *
     * @param callback function that takes state and deal with it,
     * it should be provided from the client
     * @returns a function that removes the listener
     */
    addConnectivityListener(callback: (state: CONNECTION_STATE) => void): () => void;
    /**
     * handle pause and resume states from the pos device
     *
     * @param callback callback to run on pause or resume
     * @returns remover for listener
     */
    addPauseListener(callback: (is_pause: boolean) => void): () => void;
    /**
     * handle busy and confirm states from the pos device
     *
     * @param callback callback to run on confirm or busy
     * @returns remover for listener
     */
    addBusyListener(callback: (is_busy: boolean) => void): () => void;
    /**
     * add a reconnect listener to auto reconnect after disconnection
     * retruns a remover to remove the listener
     *
     * @param delay delay for reconnect
     * @returns a remover function
     */
    addAutoReconnect(delay?: number): () => void;
    getConenctor(): NearpayConnector | undefined;
    getConnectorType(): NEARPAY_CONNECTOR | undefined;
    getCurrentConnectionInfo(): ConnectionInfo | undefined;
    getAvaliableConnector(): Promise<ConnectorInfo[]>;
    private releaseConnector;
    /**
     * will return undefined when connection success, or else it will return a string
     * with the error message
     */
    connect(connectionInfo: ConnectionInfo): Promise<void>;
    /**
     * connect to the last user used
     *
     * @returns connection error
     */
    connectToLastUser(): Promise<void>;
    reconnect(profileId: string): Promise<void>;
    /**
     *  send data to pos, will send only if the connection is avalible and
     * the device is not in pause mode
     *
     * @param data data to send to pos
     * @returns promise of value or undefined
     */
    send(data: RemoteJobRequest<any>): Promise<any>;
    /**
     * mark the last message as rejected
     */
    cancelJob(reason?: string): void;
    isConnected(): boolean;
    isLogedIn(): boolean;
    getState(): CONNECTION_STATE;
    isPaused(): boolean;
    isBusy(): boolean;
    disconnectDevice(): void;
    /**
     * forget the current conncetion info
     *
     * @returns boolean of the forget
     */
    forgetDevice(): Promise<boolean | undefined>;
    getTerminal(): Terminal;
    /**
     *
     * @returns indicates if there is a job not finished yet
     */
    hasPendingJob(): boolean;
    /**
     * will try to recover if the connetion disonnected
     *
     not finished yet
     */
    private recoveryAfterDisconnection;
    private getIdOrGenerate;
    /**
     * check if the profile id saved is valid or not
     * if valid then it can be used to connect
     * else it will ask for new uuid
     *
     * @param connectionInfo ip and port of connection
     * @returns boolean indicates the profile id is valid
     */
    private checkProfileIdIsValid;
    /**
     * request a connection uuid from the POS device
     * device could response with "busy" or "uuid:<uuid-to-use>"
     *
     * @param connectionInfo
     * @returns uuid or undefined
     */
    private requestConnectionUuid;
    /**
     * start new connection with the pos device
     * @param connectionInfo connection info
     * @param estableshedUuid profile uuid to use
     * @returns
     */
    private StartConnection;
    /**
     * we started using this new methods after we added the react native part to the project
     * since there is platform specific code that will apply only to certain platforms, like localStorage
     */
    getProfile(): Promise<ProfileType | undefined>;
    saveProfile(profile: ProfileType): Promise<void>;
    getLastConnection(): Promise<ConnectionInfo | undefined>;
    saveConnection(connection: ConnectionInfo): Promise<void>;
}

/**
 * Connectors are the part that connects the SDK with the
 * POS device, this is an abstract connector that will be inherited
 * by every connector implementation
 *
 * every connector will have its special way of
 * connecting and disconnecting, but this is general notes:
 *  1- connection should be async funciton that will resolve only when
 *      connection is estableshed
 *  2- diconnection could happen in 2 ways, intended and not-intended:
 *      every implementation should take care of both cases, the intended disconnect
 *      will generate a LOGOUT event, but the unintended will generate DISCONNECT
 */
declare class NearpayConnector {
    protected nearpay: Nearpay;
    protected connection_manager: ConnectionManager;
    protected listener: NearpayListener;
    protected connectionInfo: ConnectionInfo;
    /**
     *  return a string on error indicating the error, or
     *  else it will return undefined if it success
     */
    connect(profileId: string): Promise<void>;
    /**
     * important note: this function should handle only the regular disconnections
     * not the manual ones!
     *
     * manual disconnect (logout) will be handled using the releaseconnector
     * function in nearpay object
     */
    disconnect(options: ConnectorDisconnectOptions | undefined): void;
    send(data: object): Promise<any>;
    reconnect(profileId: string): Promise<void>;
    isConnected(): boolean;
    getType(): NEARPAY_CONNECTOR | undefined;
    getName(): string;
    getInfo(): Promise<ConnectorInfo>;
    getConnectionInfo(): ConnectionInfo | undefined;
    constructor(nearpay: Nearpay, connection_manager: ConnectionManager, listener: NearpayListener, connectionInfo: ConnectionInfo);
}

declare enum NEARPAY_CONNECTOR {
    WS = "Wireless"
}
type WsConnectionInfo = {
    type: NEARPAY_CONNECTOR.WS;
    ip: string;
    port: string;
};
type ConnectionInfo = WsConnectionInfo;
type ConnectorInfo = {
    name: string;
    type: NEARPAY_CONNECTOR;
    available: boolean;
};

export { CONNECTION_STATE, ConnectionInfo, ConnectorInfo, LabelField, LocalizationField, Merchant, NEARPAY_CONNECTOR, NameField, Nearpay as NearPay, PURCHASE_STATUS, ProfileType, PurchaseOptions, RECONCILIATIONS_QUERY_STATUS, RECONCILIATION_QUERY_STATUS, RECONCILIATION_STATUS, REFUND_STATUS, REVERSAL_STATUS, ReconcileOptions, ReconciliationBanner, ReconciliationBannerList, ReconciliationDetailsType, ReconciliationLabelField, ReconciliationReceipt, ReconciliationSchemesDetailsType, ReconciliationSchemesType, RefundOptions, RemotePurchaseResponse, RemoteReconciliationResponse, RemoteRefundResponse, RemoteReversalResponse, ReversalOptions, SessionData, SessionTransaction, TRANSACTIONS_QUERY_STATUS, TRANSACTION_QUERY_STATUS, TransactionBanner, TransactionBannerList, TransactionData, TransactionReceipt, TransactionType, WsConnectionInfo };
